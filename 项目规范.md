# 项目模块划分

**对于公共模块：**

- 尽量减少外部依赖，比如lombok就无须依赖，重的依赖也不要放到该模块中
- 将项目中公共的组件，比如util包，基础类等抽象到公共模块中
- 涉及到项目公共配置，比如SpringBoot配置等，可以考虑抽出个公共业务模块

所以针对以上几点，可以大致划分为：

- common-base: 最基础的模块，仅包含util，基础类等业务无关组件，不要依赖数据库，web服务等中间件
- common-biz：基础业务模块，包含公共异常处理，公共配置（SpringBoot），日志追踪等业务相关的，此包也可以根据项目的大小和组件的规模再次拆分，或者单独抽出个项目单独维护



**对于业务模块**，比如基础信息模块，需要拆分两个子模块：api子模块和service子模块。

- api子模块：对外提供feign client接口，实体信息等。其他微服务模块通过引入该api模块与其交互。
- service子模块：模块内部逻辑实现。

# @Transactional注解约束

在需要使用事务的方法中，统一使用如下注解，禁止使用`@Transactional`注解

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)
public @interface Tx {
    // Do Nothing
}
```

理由：

- `@Transactional`注解默认在产生`RuntimeException`和`Error`才会回滚，而出现checked exceptions 不会回滚，最好定义一个统一的异常注解，指定事务发生了什么异常会回滚；
- 避免在某个地方擅自更改事务的传播属性，隔离级别，回滚机制，导致系统不一致，出问题难以排查。

# 复杂SQL处理

尽量简化SQL。复杂拼装、组合逻辑放在代码中处理。

理由：

- 复杂数据库操作，比如大量连表，子查询，可以考虑将一个大的sql拆开，采用批量查询模式，在内存中进行组合，分组等操作，这样可以大大提高查询性能。
- 越简单的sql，我们去分析SQL查询计划时更易找到优化点，比如某个字段缺少索引等，更利于排查。

# 数据库中的浮点数类型

在数据库中小数统一使用decimal类型，并明确指定小数位数。

理由：

- double 和 float 都可能造成精度损失，在代码层面需要使用BigDecimal来规避该问题，推荐利用`BigDecimal(String val)` 字符串构造方法来生成。

# Lomok插件使用规则

基础组件尽量减少外部依赖，在业务模块中可以采用Lomok。

# 项目中的枚举字段定义

涉及status，type等类型的数据，最好用枚举来表示，用魔法数字或者字符串无法阅读和维护，代码中也不应该出现魔法常量。

用tinyInt来进行处理枚举相关的业务数据库字段；枚举需要至少传输 code 与 desc 两个属性。

使用方式如下：

- 数据库落库时，类型：tinyInt，值：取枚举的code属性
- 代码中引用时，ProjectType.ENABLED
- 响应给前端以及从前端接收时，类型：string，值：ENABLED、DISABLED

枚举定义示例：

```Java
/**
 * 项目类型
 *
 * @author 明山
 */
public enum ProjectType {
    /**
     * 启用，项目可以被展示和使用
     */
    ENABLED(0, "启用"),

    /**
     * 禁用，项目不可操作
     */
    DISABLED(1, "禁用");

    private int code;
    private String desc;

    ProjectType(int code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public int getCode() {
        return code;
    }


    public String getDesc() {
        return desc;
    }

}
```

# Feign Client 使用问题及API规范

在每一个FeignClient接口中指定 contextId（contextId需要用服务名 + 业余名 拼接，保证唯一性）

```
@FeignClient(value = "optical-net-planning-resource-htest", contextId = "Resource-TransElement", path = "/onp/resource/element")
```

对于复杂查询，比如分页查询等，要考虑Feign调用时，需要采用Post请求，把请求体放到body里面。采用GET请求时，实体传输时会出现无法传输的情况。

# 循环代码块中的数据库操作

建议不要在for循环中出现出现操作数据库相关逻辑，因为for循环的列表是由外部输入的，无法确切预知数据规模，可能造成操作响应超时等不可预知的问题。

# 参数校验和局部变量校验格式

在一个方法里面，需要对参数进行校验，推荐使用`Assert.notNull` 相关来进行参数校验，抛出 `IllegalArgumentException`

```java
public AutoRouteResponseModel calcFaultRouteAll(String projectId) {
    Assert.notNull(projectId, "projectId 不能为空");
	
    String x = null;
    
    Preconditions.checkArgument(!StringUtils.isBlank(x), "x 不能为空");
}
```

对于函数内部的局部变量进行校验时，推荐使用guava 的 `Preconditions.checkArgument` 来进行校验，消除if else，快速失败，减少逻辑冗余。

# 查询的接口，不允许出现业务异常，如果查询不到，返回空

下面是一个通过feign client 查询用户的例子：

```java
// 通过feign调用
User user = userClient.get(1).fetchData();

if (user == null) {
   // DO 
} else {
   // DO
}
```

如果`userClient.get(1)`方法 查不到 user的情况下 抛出以业务异常，调用者想知道返回的结果，就必须try catch，这样就会用try catch来做业务流转，严重违背编码规范（禁止使用try catch来做业务判断）。
