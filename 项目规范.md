# 项目模块划分

**对于公共模块：**

- 尽量减少外部依赖，比如lombok就无须依赖，重的依赖也不要放到该模块中
- 将项目中公共的组件，比如util包，基础类等抽象到公共模块中
- 涉及到项目公共配置，比如SpringBoot配置等，可以考虑抽出个公共业务模块

所以针对以上几点，可以大致划分为：

- common-base: 最基础的模块，仅包含util，基础类等业务无关组件，不要依赖数据库，web服务等中间件
- common-biz：基础业务模块，包含公共异常处理，公共配置（SpringBoot），日志追踪等业务相关的，此包也可以根据项目的大小和组件的规模再次拆分，或者单独抽出个项目单独维护



**对于业务模块**，比如基础信息模块，需要拆分两个子模块：api子模块和service子模块。

- api子模块：对外提供feign client接口，实体信息等。其他微服务模块通过引入该api模块与其交互。
- service子模块：模块内部逻辑实现。

# @Transactional注解约束

在需要使用事务的方法中，统一使用如下注解，禁止使用`@Transactional`注解

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)
public @interface Tx {
    // Do Nothing
}
```

理由：

- `@Transactional`注解默认在产生`RuntimeException`和`Error`才会回滚，而出现checked exceptions 不会回滚，最好定义一个统一的异常注解，指定事务发生了什么异常会回滚；
- 避免在某个地方擅自更改事务的传播属性，隔离级别，回滚机制，导致系统不一致，出问题难以排查。

# 复杂SQL处理

尽量简化SQL。复杂拼装、组合逻辑放在代码中处理。

理由：

- 复杂数据库操作，比如大量连表，子查询，可以考虑将一个大的sql拆开，采用批量查询模式，在内存中进行组合，分组等操作，这样可以大大提高查询性能。
- 越简单的sql，我们去分析SQL查询计划时更易找到优化点，比如某个字段缺少索引等，更利于排查。

# 数据库中的浮点数类型

在数据库中小数统一使用decimal类型，并明确指定小数位数。

理由：

- double 和 float 都可能造成精度损失，在代码层面需要使用BigDecimal来规避该问题，推荐利用`BigDecimal(String val)` 字符串构造方法来生成。

# Lomok插件使用规则

基础组件尽量减少外部依赖，在业务模块中可以采用Lomok。

# 项目中的枚举字段定义

涉及status，type等类型的数据，最好用枚举来表示，用魔法数字或者字符串无法阅读和维护，代码中也不应该出现魔法常量。

用tinyInt来进行处理枚举相关的业务数据库字段；枚举需要至少传输 code 与 desc 两个属性。

使用方式如下：

- 数据库落库时，类型：tinyInt，值：取枚举的code属性
- 代码中引用时，ProjectType.ENABLED
- 响应给前端以及从前端接收时，类型：string，值：ENABLED、DISABLED

枚举定义示例：

```Java
/**
 * 项目类型
 *
 * @author 明山
 */
public enum ProjectType {
    /**
     * 启用，项目可以被展示和使用
     */
    ENABLED(0, "启用"),

    /**
     * 禁用，项目不可操作
     */
    DISABLED(1, "禁用");

    private final int code;
    private final String desc;

    ProjectType(int code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public int getCode() {
        return code;
    }


    public String getDesc() {
        return desc;
    }

}
```

# Feign Client 使用问题及API规范

在每一个FeignClient接口中指定 contextId（contextId需要用服务名 + 业余名 拼接，保证唯一性）

```
@FeignClient(value = "optical-net-planning-resource-htest", contextId = "Resource-TransElement", path = "/onp/resource/element")
```

对于复杂查询，比如分页查询等，要考虑Feign调用时，需要采用Post请求，把请求体放到body里面。采用GET请求时，实体传输时会出现无法传输的情况。

# 循环代码块中的数据库操作

建议不要在for循环中出现出现操作数据库相关逻辑，因为for循环的列表是由外部输入的，无法确切预知数据规模，可能造成操作响应超时等不可预知的问题。

# 参数校验和局部变量校验格式

在一个方法里面，需要对参数进行校验，推荐使用`Assert.notNull` 相关来进行参数校验，抛出 `IllegalArgumentException`

```java
public AutoRouteResponseModel calcFaultRouteAll(String projectId) {
    Assert.notNull(projectId, "projectId 不能为空");
	
    String x = null;
    
    Preconditions.checkArgument(!StringUtils.isBlank(x), "x 不能为空");
}
```

对于函数内部的局部变量进行校验时，推荐使用guava 的 `Preconditions.checkArgument` 来进行校验，消除if else，快速失败，减少逻辑冗余。

# 查询的接口，不允许出现业务异常，如果查询不到，返回空

下面是一个通过feign client 查询用户的例子：

```java
// 通过feign调用
User user = userClient.get(1).fetchData();

if (user == null) {
   // DO 
} else {
   // DO
}
```

如果`userClient.get(1)`方法 查不到 user的情况下 抛出以业务异常，调用者想知道返回的结果，就必须try catch，这样就会用try catch来做业务流转，严重违背编码规范（禁止使用try catch来做业务判断）。

# 数据库冗余设计

要分清楚场景，有些是属于快照，有些是属于冗余。

1.快照场景：交易场景大部分是数据快照，而不是冗余，用户下单时候的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新的话再去关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。

2.冗余场景：一般数据改动的可能性少，而查询多的场景会使用冗余，例如淘宝的店铺名称，淘宝商家中心会有这个字段，可能里面的商家论坛也有，再假设聚划算这种独立的大业务自己也存一份，再来个垂直频道电器城的后台管理也独立存一份，这种场景是由于对查询性能要求高产生的，所以必须要冗余，在业务的取舍上，肯定是对让用户更快看到信息，那么不可避免的是带来维护成本的增加，对于数据一致性问题，只要做到最终一致就可以了，分布式的CAP原则的实际应用基本都是通过牺牲数据一致性(C)来保证高可用(A)和高可靠(P)， 因为这种场景大部分都是可以接受短暂的数据不一致的，对业务的影响及其微小。

在微服务时代下，尽量避免过多的关联查询，将原本需要关联查询的业务拆分开来，通过REST接口来互相调用，在内存中进行组合分组，最终达到目的。

参考：

https://www.zhihu.com/question/50662784/answer/147731726

# 服务之间通过接口交互，禁止出现一个服务调其他业务的非服务层代码

`封装`是开发的基本规范，服务应该保证内部逻辑的封装性，对外暴露接口，调用者不需要关系内部的实现。所以`禁止出现一个服务调其他业务的dao层代码`。

## 一行代码不要超过idea默认的120字符

在idea中，如果一行代码字符数超过120，每次阅读代码都要拉滚动条，后续代码阅读十分困难，所以一行代码不要超过idea默认的120字符。

idea 的设置中，找到以下路径：Wrapping and Braces -> Keep when reformatting -> Ensure rigth margin is not exceeded ，将`Ensure rigth margin is not exceeded`勾选上，
当这个选择之后，ctrl  + alt + L  格式化代码的时候，就会自动换行。
